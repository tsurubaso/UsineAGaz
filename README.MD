<!-- for visualisation Ctrl + Shift + V -->
---


`crypto` est le module natif Node.js.
Il sert uniquement au **hachage SHA-256**, pas Ã  la signature elliptique.

`net` est le module TCP bas niveau.
Ici, tu construis volontairement un rÃ©seau **sans HTTP, sans WebSocket**, pour rester au plus proche dâ€™un vrai protocole P2P.

`@noble/curves/secp256k1` est la librairie cryptographique moderne.
Elle ne fait **que de la crypto pure**, sans rÃ©seau, sans encodage implicite.

`hexToBytes` est indispensable : noble **ne travaille jamais avec des strings**, uniquement avec des bytes (`Uint8Array`).

---

### 0. Configuration du nÅ“ud

Chaque instance du programme est **le mÃªme code**, mais son comportement dÃ©pend de lâ€™environnement :

* `NODE_ID` : identifie le nÅ“ud (node1, node2, node3)
* `NODE1_PRIVATE_KEY` : clÃ© privÃ©e du MASTER uniquement
* `NODE1_PUBLIC_KEY` : clÃ© publique du MASTER (connue de tous)

---

### 1. Ã‰tat local

```js
let blockchain = [];
```

Chaque nÅ“ud possÃ¨de **sa propre copie locale** de la blockchain.
Il nâ€™y a pas de base de donnÃ©es ici :

* câ€™est volontaire
* Ã§a permet de raisonner uniquement sur la logique protocolaire

---

### 2. Fonctions cryptographiques (hors rÃ©seau)

Cette section est trÃ¨s importante conceptuellement.

ğŸ‘‰ **Aucune de ces fonctions ne connaÃ®t le rÃ©seau, les sockets ou les peers**.

---

#### Hash structurel du bloc

`calculateHash(...)`

Ce hash :

* est **lisible** (hex)
* est **stockÃ© dans le bloc**
* sert Ã  **chaÃ®ner les blocs entre eux**

Il garantit :

* lâ€™intÃ©gritÃ© du contenu
* la continuitÃ© de la chaÃ®ne

Ce hash **nâ€™est PAS utilisÃ© pour la signature**.
Câ€™est volontairement sÃ©parÃ©.

---

#### Hash cryptographique pour la signature

`hashBlockForSignature(block)`

Ici, on prÃ©pare **le message cryptographique**.

Points clÃ©s :

* mÃªme contenu logique que le hash structurel
* mais sortie en **bytes**, pas en hex
* format exigÃ© par noble

ğŸ‘‰ Câ€™est ce hash prÃ©cis qui est signÃ© et vÃ©rifiÃ©.
ğŸ‘‰ Aucune ambiguÃ¯tÃ© possible sur ce qui est signÃ©.

---

#### Signature du bloc (MASTER uniquement)

`signBlock(block, privateKeyHex)`

Processus exact :

1. Calcul du hash cryptographique (bytes)
2. Conversion de la clÃ© privÃ©e hex â†’ bytes
3. Signature elliptique secp256k1
4. Conversion du rÃ©sultat en hex pour le transport rÃ©seau

Important conceptuellement :

* **on signe des bytes**
* **on transporte du hex**
* la frontiÃ¨re est claire

---

#### VÃ©rification de la signature

`verifyBlockSignature(block)`

Câ€™est le miroir exact de la signature.

Le nÅ“ud :

* reconstruit le message (hash bytes)
* reconvertit signature et clÃ© publique en bytes
* appelle `secp256k1.verify(...)`

Si Ã§a Ã©choue :

* soit le contenu a Ã©tÃ© modifiÃ©
* soit la signature ne correspond pas au signataire

ğŸ‘‰ Aucune confiance implicite.
ğŸ‘‰ ZÃ©ro logique mÃ©tier ici, uniquement de la crypto.

---

### 3. Bloc Genesis

`createGenesisBlock()`

Le Genesis est :

* dÃ©terministe
* identique sur tous les nÅ“uds
* non dÃ©pendant du rÃ©seau

Il **nâ€™est pas signÃ© ici**.
La signature est ajoutÃ©e plus tard, uniquement par le MASTER.

Câ€™est trÃ¨s propre comme sÃ©paration de responsabilitÃ©s.

---

### 4. Initialisation de la blockchain

Tous les nÅ“uds :

* crÃ©ent le Genesis localement
* le poussent dans leur blockchain

Mais :

* **seul node1 le signe**
* les autres nÅ“uds le reÃ§oivent signÃ© via le rÃ©seau

Câ€™est exactement le rÃ´le dâ€™un **nÅ“ud autoritÃ© initial**.

---

### 5. RÃ©seau : peers et envoi

Les peers sont calculÃ©s dynamiquement :

```js
["node1", "node2", "node3"].filter(...)
```

Chaque nÅ“ud sait :

* qui il est
* qui il nâ€™est pas

`sendMessage()` :

* ouvre une connexion TCP
* envoie un message JSON brut
* ferme la connexion

ğŸ‘‰ Simple, lisible, suffisant pour un proto P2P.

---

### 6. Serveur TCP

Chaque nÅ“ud Ã©coute sur le mÃªme port.

Ã€ la rÃ©ception :

1. Parsing JSON
2. VÃ©rification du type de message
3. Validation du bloc

La validation est **strictement ordonnÃ©e** :

1. hash structurel
2. signature cryptographique

ğŸ‘‰ Si le hash Ã©choue, inutile de vÃ©rifier la signature.
ğŸ‘‰ Câ€™est exactement lâ€™ordre logique attendu.

---

### 7. DÃ©marrage

Au dÃ©marrage :

* chaque nÅ“ud lance son serveur
* le MASTER vÃ©rifie quâ€™il possÃ¨de bien une clÃ© privÃ©e
* le MASTER diffuse le Genesis aprÃ¨s un dÃ©lai

Le `setTimeout` est lÃ  pour :

* laisser les autres nÅ“uds dÃ©marrer
* Ã©viter des erreurs de connexion prÃ©maturÃ©es

---

### En rÃ©sumÃ©

On a :

* une **base blockchain saine**
* une **crypto moderne correctement utilisÃ©e**
* une **sÃ©paration nette entre logique, crypto et rÃ©seau**
* un Genesis signÃ© proprement
* une validation rÃ©aliste cÃ´tÃ© nÅ“uds
